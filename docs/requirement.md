# 채팅 애플리케이션 개발 계획 (Polling 방식 사용)

## 1. 프로젝트 목표

사용자 인증을 통과한 사람들에게 끊김 없는 채팅 경험을 제공하면서도 유지보수가 쉬운 구조를 갖춘다. 요구된 모든 기능은 명확한 기준에 따라 완성하고, Flux 기반 데이터 흐름을 통해 상태를 예측 가능하게 만든다. 비즈니스 로직은 Context API로 중앙 집중화해 컴포넌트 간 결합도를 낮추며, 폴링 스케줄을 통해 메시지 스트림을 꾸준히 동기화한다.

* **핵심 기능 우선 구현:** 로그인/가입, 채팅방 개설·참여, 메시지 작성, 미리보기 등 사용자 경험에 직접적인 기능부터 우선 완성한다.
* **상태 최소화:** 불필요한 전역 상태는 제거하고, 액션 기반 데이터 흐름을 선언적으로 표현한다.
* **예측 가능한 데이터 플로우:** Flux 패턴을 도입해 액션 → 디스패처 → 스토어 → 뷰 순환을 유지한다.
* **중앙 집중 비즈니스 로직:** Context API를 활용하여 인증 정보, 채팅방 메타데이터, 메시지 캐시 등을 일관된 인터페이스로 공유한다.

## 2. 기술 스택 및 설계 개요

### Next.js 풀스택(App Router)
* **단일 프레임워크:** Next.js App Router(React 18)를 사용해 UI와 API를 하나의 프로젝트에서 관리한다.
* **클라이언트 계층:** Flux + Context API + 커스텀 훅으로 상태를 선언적으로 관리한다.
* **Hono 기반 서버 계층:** 동일 Next.js 프로젝트의 `app/api/*` 라우트에서 Hono 애플리케이션을 실행한다.
    * `@hono/vercel`로 Hono 라우터를 Vercel Serverless Functions와 연결한다.
    * 모든 `/api/*` 요청은 Hono 미들웨어를 거쳐 Supabase REST API로 전달된다.
    * 세션 토큰 검증, 권한 검사, rate limit, 감사 로그 기록 등을 Hono에서 처리한다.
    * 메시지 변환, 폴링 스케줄 관리 등 부가 로직은 순수 함수로 쪼개 테스트 가능하게 유지한다.

### 백엔드 서비스 (BaaS - Supabase)
* **데이터베이스:** PostgreSQL (Supabase 관리)
* **인증:** Supabase Auth로 회원 가입 및 로그인 처리
* **실시간 동기화:** Realtime 대신 **주기적 Polling 방식**으로 메시지를 동기화한다.
* **RLS 사용 여부:** Row Level Security는 비활성화하고, **Hono 계층이 모든 접근 제어를 담당**한다. 서비스 롤 키는 서버 환경 변수에만 저장하며, 클라이언트에는 노출하지 않는다.

### 배포 (Deployment)
* **플랫폼:** Vercel
    * Next.js 풀스택 애플리케이션 하나만 배포하여 페이지와 API(Hono)가 동시에 올라간다.
    * 서버리스 함수에서 Hono가 Supabase와 통신하고, React는 동일 도메인의 `/api/*` 엔드포인트만 호출한다.

## 3. 핵심 기능 명세

* **로그인/회원가입**
    * 사용자는 이메일 기반 계정을 생성하고, 인증된 사용자만 애플리케이션에 접근한다.
* **채팅방 개설**
    * 사용자는 새로운 방을 만들고 방 이름, 설명, 공개 범위를 설정한다.
* **채팅방 참여**
    * 전체 채팅방 목록을 조회하거나 검색하고, 원하는 방에 합류한다.
* **메시지 송신 (텍스트/이모지)**
    * 텍스트와 이모지를 조합한 메시지를 작성할 수 있다.
    * 메시지는 **Hono → Supabase REST API → 폴링 응답** 흐름을 통해 다른 참가자에게 전달된다.
* **좋아요(리액션)**
    * 다른 사용자의 메시지에 좋아요를 누르면 집계 수가 메시지 옆에 표시된다.
* **북마크**
    * 관심 메시지를 북마크하여 별도로 모아볼 수 있으며, 원본 메시지와 연결된다.
* **자신의 메시지 삭제**
    * 사용자는 본인이 작성한 메시지를 삭제할 수 있으며, 삭제 후 다른 사용자에게 노출되지 않는다.
