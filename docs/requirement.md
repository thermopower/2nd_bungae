# 채팅 애플리케이션 개발 계획 (Polling 방식 사용)

## 1. 프로젝트 목표

사용자 로그인을 기반으로 한 채팅 경험을 끊김 없이 제공하면서도 유지보수하기 쉬운 구조를 갖춘 애플리케이션을 구축한다. 모든 기능은 명확한 요구사항에 따라 완성도 있게 제공되고, 상태 관리는 Flux 기반 데이터 흐름으로 측정 가능하며 예측 가능해야 한다. 복잡한 비즈니스 로직은 Context API로 중앙 집중화해 컴포넌트 간 결합도를 낮추고, 폴링 스케줄을 통해 메시지 스트림을 꾸준히 동기화한다.

* **핵심 기능 품질 보장:** 로그인/가입, 채팅방 관리, 메시지 입력, 미리보기 등 최종 사용자 경험과 직접 연결된 기능부터 우선 구현한다.
* **상태 최소화:** 불필요한 전역 상태를 줄이고, 선언적 데이터 흐름을 통해 디버깅 가능성을 확보한다.
* **예측 가능한 데이터 흐름:** Flux 아키텍처를 채택해 액션→디스패처→스토어→뷰 흐름을 유지한다.
* **중앙 집중 비즈니스 로직:** Context API를 이용하여 인증, 채팅방 메타 정보, 메시지 캐시 등을 공유한다.

## 2. 기술 스택 및 설계 개요

### Frontend
* **아키텍처:** Flux
* **주요 라이브러리:** React
* **상태 관리/데이터 흐름:** Context API + 커스텀 훅

### Backend
* **런타임:** Node.js
* **프레임워크/미들웨어:** Hono 애플리케이션
    * React 클라이언트와 Supabase 사이의 미들웨어 역할을 수행하며, 모든 데이터 요청·변경은 Hono를 경유한다.
    * 세션 토큰, 사용자 권한, 요청 rate limit 등을 Hono 계층에서 검증하고, 성공한 요청만 Supabase REST API에 전달한다.
    * 폴링 스케줄링, 메시지 서식 변환, 감사 로그 기록 등 부가 로직을 순수 함수 단위로 구성한다.

### 백엔드 서비스 (BaaS - Supabase)
* **데이터베이스:** PostgreSQL (Supabase 관리)
* **인증:** Supabase Auth로 사용자 계정 생성과 로그인 처리
* **실시간 동기화:** Realtime을 사용하지 않고 **주기적 Polling 방식**으로 메시지를 동기화한다.
* **RLS 사용 여부:** Row Level Security는 활성화하지 않고, **Hono 미들웨어가 모든 접근 제어를 담당**한다. 서비스 롤 키는 서버 측 환경 변수에만 보관하며, 클라이언트에는 노출하지 않는다.

### 배포 (Deployment)
* **플랫폼:** Vercel
    * React 클라이언트와 Hono 기반 서버 모두 Vercel에서 배포한다.
    * Hono 앱은 Vercel Serverless Functions로 배포되며, Supabase와 통신하는 단일 진입점이 된다.

## 3. 핵심 기능 명세

* **로그인/회원가입**
    * 사용자는 이메일 기반 계정을 생성하고, 인증된 사용자만 앱에 접근한다.
* **채팅방 개설**
    * 사용자는 새로운 채팅방을 만들고 방 이름, 설명, 공개 범위를 지정한다.
* **채팅방 참여**
    * 전체 채팅방 목록을 조회하거나 검색하고, 원하는 방에 합류할 수 있다.
* **메시지 송신 (텍스트/이모지)**
    * 사용자는 텍스트와 이모지를 조합한 메시지를 보낼 수 있다.
    * 전송된 메시지는 **Hono → Supabase REST API → 폴링 응답** 흐름을 통해 참가자에게 전달된다.
* **좋아요(리액션)**
    * 다른 사용자의 메시지에 좋아요를 누르면 집계 수가 메시지 옆에 표시된다.
* **북마크**
    * 관심 메시지를 북마크해 별도로 모아 볼 수 있으며, 원본 메시지와 연동된다.
* **자신의 메시지 삭제**
    * 사용자는 본인이 작성한 메시지를 삭제할 수 있으며, 삭제 후에는 다른 사용자에게 노출되지 않는다.
